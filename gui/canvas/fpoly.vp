(include 'sys/func.inc)
(include 'gui/canvas/class.inc)
(include 'class/vector/class.inc)
(include 'gui/points/class.inc)

(def-method 'canvas 'set_edges)
	;inputs
	;r0 = canvas object (ptr)
	;r1 = vector of points objects (ptr)
	;r2 = x (16.16)
	;r3 = y (16.16)
	;r4 = y scale (int)
	;outputs
	;r0 = canvas object (ptr)
	;r1 = min_x (16.16)
	;r2 = min_y (16.16)
	;r3 = max_x (16.16)
	;r4 = max_y (16.16)
	;trashes
	;all but r0

	(ptr 'this)
	(union
		'(ptr 'polygons)
		'(pptr 'iter_end_polygons 'iter_begin_polygons))
	(int 'ys 'ye 'xs 'xe 'x 'y 'x1 'y1)
	(pint 'iter_edge1 'iter_edge2 'iter_begin_polygon 'iter_end_polygon)
	(uint 'length 'yscale 'cy 'cy1)

	(push-scope)
	(entry 'canvas 'set_edges {this, polygons, x, y, yscale})

	;fill edges, find min and max xy, clip edges not visible or redundant
	(assign {yscale * this->canvas_cy, yscale * this->canvas_cy1} {cy, cy1})
	(assign {x + 0.5, y + 0.5, max_int, min_int, max_int, min_int, 0} {x, y, xs, xe, ys, ye, length})
	(call 'vector 'get_iters {polygons} {_, iter_begin_polygons, iter_end_polygons})
	(loop-while {iter_begin_polygons != iter_end_polygons})
		(call 'points 'get_iters {*iter_begin_polygons} {_, iter_begin_polygon, iter_end_polygon})
		(call 'array 'set_capacity {this->canvas_edges, length + ((iter_end_polygon - iter_begin_polygon) >> 4) * (edge_size >> 3)})
		(call 'array 'get_begin {this->canvas_edges} {_, iter_edge1})
		(assign {iter_edge1 + length * long_size} {iter_edge2})
		(vpif {iter_end_polygon - iter_begin_polygon >= long_size * 6})
			(assign {iter_end_polygon[-long_size * 2] + x} {x1})
			(assign {(iter_end_polygon[-long_size] + y) * yscale >>> fp_shift} {y1})
			(loop-start)
				(vp-def (r_xlow r_iter_edge2 r_xhigh r_x r_y r_x1 r_x2 r_y1 r_y2 r_xs r_xe r_ys r_ye r_cy r_cy1))
				(assign {x1, y1, xs, xe, ys, ye, cy, cy1, iter_edge2,
					iter_begin_polygon[0] + x, (iter_begin_polygon[long_size] + y) * yscale >>> fp_shift}
					(list r_x1 r_y1 r_xs r_xe r_ys r_ye r_cy r_cy1 r_iter_edge2 r_x2 r_y2))
				(vpif (list r_y1 '!= r_y2))
					(vp-cpy-rr r_x2 r_x)
					(vp-asr-cr fp_shift r_x)
					(vpif (list r_x '< r_xs))
						(vp-cpy-rr r_x r_xs)
					(endif)
					(vpif (list r_x '> r_xe))
						(vp-cpy-rr r_x r_xe)
					(endif)
					(vp-cpy-cr 1 r_x)
					(vpif (list r_y2 '< r_y1))
						(vp-swp-rr r_x1 r_x2)
						(vp-swp-rr r_y1 r_y2)
						(vp-cpy-cr -1 r_x)
					(endif)
					(breakif (list r_y2 '<= r_cy))
					(breakif (list r_y1 '>= r_cy1))
					(vp-cpy-rr r_x2 r_xlow)
					(vp-cpy-rr r_y2 r_y)
					(vp-sub-rr r_x1 r_xlow)
					(vp-sub-rr r_y1 r_y)
					(vp-ext-rr r_xlow r_xhigh)
					(vp-div-rrr r_y r_xhigh r_xlow)
					(vpif (list r_y1 '< r_cy))
						(vp-cpy-rr r_cy r_y)
						(vp-sub-rr r_y1 r_y)
						(vp-mul-rr r_xlow r_y)
						(vp-cpy-rr r_cy r_y1)
						(vp-add-rr r_y r_x1)
					(endif)
					(vp-cpy-ri-i r_x1 r_iter_edge2 edge_x)
					(vp-cpy-ri-i r_y1 r_iter_edge2 edge_ys)
					(vp-cpy-ri-i r_y2 r_iter_edge2 edge_ye)
					(vp-cpy-ri-i r_xlow r_iter_edge2 edge_dda)
					(vp-cpy-ri-i r_x r_iter_edge2 edge_w)
					(vpif (list r_y1 '< r_ys))
						(vp-cpy-rr r_y1 r_ys)
					(endif)
					(vpif (list r_y2 '> r_ye))
						(vp-cpy-rr r_y2 r_ye)
					(endif)
					(vp-add-cr edge_size r_iter_edge2)
					(assign (list r_iter_edge2 r_xs r_ys r_xe r_ye) {iter_edge2, xs, ys, xe, ye})
				(endif)
				(assign {iter_begin_polygon[0] + x} {x1})
				(assign {(iter_begin_polygon[long_size] + y) * yscale >>> fp_shift} {y1})
			(loop-until {(iter_begin_polygon + long_size * 2 => iter_begin_polygon) == iter_end_polygon})
			(assign {(iter_edge2 - iter_edge1) >> 3} {length})
		(endif)
		(assign {iter_begin_polygons + ptr_size} {iter_begin_polygons})
	(loop-end)
	(call 'array 'set_length {this->canvas_edges, length})

	(exit 'canvas 'set_edges {this, xs, ys, xe, ye})
	(pop-scope)
	(return)

(def-func-end)

(def-method 'canvas 'fpoly)
	;inputs
	;r0 = canvas object (ptr)
	;r1 = x (16.16)
	;r2 = y (16.16)
	;r3 = winding mode (0/1)
	;r4 = vector of points objects (ptr)
	;outputs
	;r0 = canvas object (ptr)
	;trashes
	;all but r0

	(ptr 'this)
	(union
		'(ptr 'polygons)
		'(pint 'sorted_list)
		'(pint 'tracker_node 'tracker_last 'tracker_list))
	(int 'ys 'ye 'xs 'xe 'x 'y 'om 'min_x 'max_x)
	(uint 'mode 'yscale 'cy 'cy1)

	(push-scope)
	(entry 'canvas 'fpoly {this, x, y, mode, polygons})

	;fill edges, find min and max xy, clip edges not visible or redundant
	(assign {1} {yscale})
	(vpif {this->canvas_flags})
		(assign {8} {yscale})
	(endif)
	(call 'canvas 'set_edges {this, polygons, x, y, yscale} {_, xs, ys, xe, ye})

	;clip check
	(assign {yscale * this->canvas_cy, yscale * this->canvas_cy1} {cy, cy1})
	(vpif {xs < this->canvas_cx1 && xe > this->canvas_cx && ys < cy1 && ye > cy})
		;setup active edge list, edge starts and coverage
		(assign {0} {tracker_list})
		(vpifnot {this->canvas_edges_start})
			(call 'sys_mem 'calloc {this->canvas_height * 8 * ptr_size} {this->canvas_edges_start, _})
		(endif)
		(vpif {this->canvas_flags})
			(assign {max_int, min_int} {min_x, max_x})
			(vpifnot {this->canvas_coverage})
				(call 'sys_mem 'calloc {this->canvas_width} {this->canvas_coverage, _})
			(endif)
		(endif)

		;edge pointers into edge starts
		(call 'array 'get_iters {this->canvas_edges} {_, tracker_node, tracker_last})
		(vp-def (r_edges_start r_edge_node r_edge_last r_edge_tmp r_edge_list_head))
		(assign {this->canvas_edges_start, tracker_node, tracker_last}
			(list r_edges_start r_edge_node r_edge_last))
		(loop-start)
			(vp-cpy-ir-i r_edge_node edge_ys r_edge_list_head)
			(vp-mul-cr ptr_size r_edge_list_head)
			(vp-add-rr r_edges_start r_edge_list_head)
			(ln-add-fnode r_edge_list_head 0 r_edge_node r_edge_tmp)
			(vp-add-cr edge_size r_edge_node)
		(loop-until (list r_edge_node '== r_edge_last))

		;for each scanline
		(loop-while {ys < ye})
			;include new edges that begin on this scanline
			(vp-def (r_tracker_list_head r_starts_node r_starts_last r_starts_new r_starts_tmp r_ys r_y))
			(assign {&(this->canvas_edges_start)[ys * ptr_size], &tracker_list, ys}
				(list r_starts_node r_tracker_list_head r_ys))
			(loop-start)
				(ln-next-fnode r_starts_node r_starts_last)
				(vp-cpy-ir-i r_starts_node edge_ys r_y)
				(continueif (list r_y '!= r_ys))
				(vp-cpy-rr r_starts_node r_starts_new)
				(ln-remove-fnode r_starts_node r_starts_last)
				(ln-add-fnode r_tracker_list_head 0 r_starts_new r_starts_tmp)
			(loop-end)

			;sort active edges on x
			(vpif {!this->canvas_flags || mode})
				(assign {0} {sorted_list})
				(vp-def (r_sorted_list_head r_tracker_node r_tracker_last r_tracker_new
					r_sorted_node r_sorted_last r_x1 r_x2))
				(assign {&sorted_list, &tracker_list} (list r_sorted_list_head r_tracker_node))
				(loop-start)
					(ln-next-fnode r_tracker_node r_tracker_last)
					(vp-cpy-rr r_tracker_node r_tracker_new)
					(ln-remove-fnode r_tracker_node r_tracker_last)
					(vp-cpy-ir-i r_tracker_new edge_x r_x1)
					(loop-flist r_sorted_list_head 0 r_sorted_node r_sorted_last)
						(vp-cpy-ir-i r_sorted_node edge_x r_x2)
					(loop-until (list r_x1 '<= r_x2))
					(ln-add-fnode r_sorted_last 0 r_tracker_new r_tracker_last)
				(loop-end)
				(assign {sorted_list} {tracker_list})
			(endif)

			;antialiased ?
			(vpif {this->canvas_flags})
				;draw edges into coverage mask
				(vp-def (r_tracker_node r_mask r_xo r_cx r_cx1 r_x r_xp r_xb r_xm r_min_x r_max_x r_w r_v))
				(assign {&tracker_list, this->canvas_coverage, int($sample_offsets + ((ys & 7) << 2)),
					1 << (ys & 7), this->canvas_cx << fp_shift, (this->canvas_cx1 - 1) << fp_shift, min_x, max_x, mode}
					(list r_tracker_node r_mask r_xo r_xm r_cx r_cx1 r_min_x r_max_x r_v))
				(vpif (list r_v '== 0))
					;odd even
					(loop-start)
						(ln-next-fnode r_tracker_node r_tracker_node)
						(vp-cpy-ir-i r_tracker_node edge_x r_x)
						(vp-add-rr r_xo r_x)
						(vpif (list r_x '< r_cx))
							(vp-cpy-rr r_cx r_x)
						(elseif (list r_x '> r_cx1))
							(vp-cpy-rr r_cx1 r_x)
						(endif)
						(vp-asr-cr fp_shift r_x)
						(vp-cpy-dr-ub r_mask r_x r_xb)
						(vpif (list r_x '< r_min_x))
							(vp-cpy-rr r_x r_min_x)
						(endif)
						(vpif (list r_x '> r_max_x))
							(vp-cpy-rr r_x r_max_x)
						(endif)
						(vp-xor-rr r_xm r_xb)
						(vp-cpy-rd-b r_xb r_mask r_x)
					(loop-end)
				(else)
					;non zero
					(loop-start)
						(ln-next-fnode r_tracker_node r_tracker_node)
						(vp-cpy-ir-i r_tracker_node edge_x r_x)
						(vp-cpy-ir-i r_tracker_node edge_w r_w)
						(vp-add-rr r_xo r_x)
						(vpif (list r_x '< r_cx))
							(vp-cpy-rr r_cx r_x)
						(elseif (list r_x '> r_cx1))
							(vp-cpy-rr r_cx1 r_x)
						(endif)
						(vp-asr-cr fp_shift r_x)
						(vp-cpy-dr-ub r_mask r_x r_xb)
						(vpif (list r_x '< r_min_x))
							(vp-cpy-rr r_x r_min_x)
						(endif)
						(vp-xor-rr r_xm r_xb)
						(vp-cpy-rd-b r_xb r_mask r_x)
						(loop-start)
							(vp-cpy-ir r_tracker_node ln_fnode_next r_tracker_node)
							(vp-cpy-ir-i r_tracker_node edge_w r_v)
							(vp-add-rr r_v r_w)
						(loop-until (list r_w '== 0))
						(vp-cpy-ir-i r_tracker_node edge_x r_x)
						(vp-add-rr r_xo r_x)
						(vpif (list r_x '< r_cx))
							(vp-cpy-rr r_cx r_x)
						(elseif (list r_x '> r_cx1))
							(vp-cpy-rr r_cx1 r_x)
						(endif)
						(vp-asr-cr fp_shift r_x)
						(vp-cpy-dr-ub r_mask r_x r_xb)
						(vpif (list r_x '> r_max_x))
							(vp-cpy-rr r_x r_max_x)
						(endif)
						(vp-xor-rr r_xm r_xb)
						(vp-cpy-rd-b r_xb r_mask r_x)
					(loop-end)
				(endif)
				(assign (list r_min_x r_max_x) {min_x, max_x})

				;flush coverage mask to scan line
				(gotoif {(ys & 7) == 7} 'flush_mask)
				(gotoif {ys + 1 == ye} 'flush_mask)
				(breakif {ys + 1 < cy1})
			(vp-label 'flush_mask)
				(vp-def (r_this r_c r_x r_y r_x1 r_mask r_m r_om r_max_x r_mask_to_coverage r_v)
					(method-input 'canvas 'span))
				(assign {this, min_x, max_x, ys >> 3} (list r_this r_x r_max_x r_y))
				(breakif (list r_x '> r_max_x))
				(vp-add-cr 1 r_max_x)
				(vp-xor-rr r_om r_om)
				(assign (list r_max_x r_y r_om) {max_x, y, om})
				(loop-start)
					(assign {$mask_to_coverage} (list r_mask_to_coverage))
					(vp-cpy-ir r_this canvas_coverage r_mask)
					(vp-cpy-rr r_x r_x1)
					(vp-cpy-rr r_om r_m)
					(loop-start)
						(vp-cpy-dr-ub r_mask r_x1 r_c)
						(vp-add-cr 1 r_x1)
						(vp-xor-rr r_c r_m)
						(breakif (list r_x1 '>= r_max_x))
					(loop-until (list r_m '!= r_om))
					(vp-lea-i r_x1 -1 r_v)
					(vp-xor-rr r_c r_c)
					(vp-cpy-rd-b r_c r_mask r_v)
					(vp-cpy-dr-ub r_mask_to_coverage r_om r_c)
					(assign (list r_m r_x1) {om, x})
					(call 'canvas 'span_noclip (list r_this r_c r_x r_y r_x1) (list r_this))
					(assign {x, max_x, y, om} (list r_x r_max_x r_y r_om))
				(loop-until (list r_x '>= r_max_x))
				(assign {max_int, min_int} {min_x, max_x})
			(else)
				;draw spans for mode
				(vp-def (r_this r_c r_x1 r_ys r_x2 r_w r_v r_tracker_node) (method-input 'canvas 'span))
				(assign {mode, this, &tracker_list} (list r_v r_this r_tracker_node))
				(vpif (list r_v '== 0))
					;odd even
					(loop-start)
						(ln-next-fnode r_tracker_node r_tracker_node)
						(assign {ys} (list r_ys))
						(vp-cpy-ir-i r_tracker_node edge_x r_x1)
						(vp-cpy-ir r_tracker_node ln_fnode_next r_tracker_node)
						(vp-cpy-ir-i r_tracker_node edge_x r_x2)
						(vp-asr-cr fp_shift r_x1)
						(vp-asr-cr fp_shift r_x2)
						(assign (list r_tracker_node) {tracker_node})
						(call 'canvas 'span (list r_this 0x80 r_x1 r_ys r_x2) (list r_this))
						(assign {tracker_node} (list r_tracker_node))
					(loop-end)
				(else)
					;non zero
					(loop-start)
						(ln-next-fnode r_tracker_node r_tracker_node)
						(assign {ys} (list r_ys))
						(vp-cpy-ir-i r_tracker_node edge_x r_x1)
						(vp-cpy-ir-i r_tracker_node edge_w r_w)
						(loop-start)
							(vp-cpy-ir r_tracker_node ln_fnode_next r_tracker_node)
							(vp-cpy-ir-i r_tracker_node edge_w r_v)
							(vp-add-rr r_v r_w)
						(loop-until (list r_w '== 0))
						(vp-cpy-ir-i r_tracker_node edge_x r_x2)
						(vp-asr-cr fp_shift r_x1)
						(vp-asr-cr fp_shift r_x2)
						(assign (list r_tracker_node) {tracker_node})
						(call 'canvas 'span (list r_this 0x80 r_x1 r_ys r_x2) (list r_this))
						(assign {tracker_node} (list r_tracker_node))
					(loop-end)
				(endif)
			(endif)

			;next sub scanline
			(breakif {(ys + 1 => ys) >= cy1})

			;step the edges and remove any dead ones
			(vp-def (r_tracker_node r_tracker_last r_ys r_x r_dda))
			(assign {&tracker_list, ys} (list r_tracker_node r_ys))
			(loop-start)
			(vp-label 'start)
				(ln-next-fnode r_tracker_node r_tracker_last)
				(vp-cpy-ir-i r_tracker_node edge_ye r_x)
				(vpif (list r_x '!= r_ys))
					(vp-cpy-ir-i r_tracker_node edge_x r_x)
					(vp-cpy-ir-i r_tracker_node edge_dda r_dda)
					(vp-add-rr r_dda r_x)
					(vp-cpy-ri-i r_x r_tracker_node edge_x)
					(goto 'start)
				(endif)
				(ln-remove-fnode r_tracker_node r_tracker_last)
			(loop-end)
		(loop-end)
	(endif)

	(exit 'canvas 'fpoly {this})
	(pop-scope)
	(return)

(vp-label 'sample_offsets)
	(apply vp-int (map (lambda (o)
		(sub o 0.5)) '(0.25 0.875 0.5 0.125 0.75 0.375 0 0.625)))

(vp-label 'mask_to_coverage)
	(apply vp-byte (map (lambda (m)
		(div (mul 0x80 (apply add (map (lambda (s)
			(logand 1 (shr m s))) (const '(range 0 8))))) 8)) (range 0 256)))

(def-func-end)
