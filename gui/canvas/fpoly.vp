(include 'sys/func.inc)
(include 'gui/canvas/class.inc)
(include 'class/vector/class.inc)
(include 'gui/points/class.inc)

(def-method 'canvas 'set_edges)
	;inputs
	;r0 = canvas object (ptr)
	;r1 = vector of points objects (ptr)
	;r2 = x (16.16)
	;r3 = y (16.16)
	;outputs
	;r0 = canvas object (ptr)
	;r1 = min_x (16.16)
	;r2 = min_y (16.16)
	;r3 = max_x (16.16)
	;r4 = max_y (16.16)
	;trashes
	;all but r0

	(ptr 'this)
	(union
		'(ptr 'polygons)
		'(pptr 'iter_end_polygons 'iter_begin_polygons))
	(int 'ys 'ye 'xs 'xe 'x 'y 'x1 'y1 'x2 'y2 'xc)
	(pint 'iter_edge1 'iter_edge2 'iter_begin_polygon 'iter_end_polygon)
	(uint 'length)

	(push-scope)
	(entry 'canvas 'set_edges {this, polygons, x, y})

	;fill edges, find min and max xy, clip edges not visible or redundant
	(assign {x + 0.5, y + 0.5, max_int, min_int, max_int, min_int, 0} {x, y, xs, xe, ys, ye, length})
	(call 'vector 'get_iters {polygons} {_, iter_begin_polygons, iter_end_polygons})
	(loop-while {iter_begin_polygons != iter_end_polygons})
		(call 'points 'get_iters {*iter_begin_polygons} {_, iter_begin_polygon, iter_end_polygon})
		(call 'array 'set_capacity {this->canvas_edges, length + ((iter_end_polygon - iter_begin_polygon) >> 4) * (edge_size >> 3)})
		(call 'array 'get_begin {this->canvas_edges} {_, iter_edge1})
		(assign {iter_edge1 + length * long_size} {iter_edge2})
		(vpif {iter_end_polygon - iter_begin_polygon >= long_size * 6})
			(assign {iter_end_polygon[-long_size * 2] + x} {x1})
			(assign {(iter_end_polygon[-long_size] + y) >>> fp_shift} {y1})
			(loop-start)
				(assign {iter_begin_polygon[0] + x} {x2})
				(assign {(iter_begin_polygon[long_size] + y) >>> fp_shift} {y2})
				(vpif {y1 != y2})
					(assign {x2 >>> fp_shift} {xc})
					(vpif {xc < xs})
						(assign {xc} {xs})
					(endif)
					(vpif {xc > xe})
						(assign {xc} {xe})
					(endif)
					(vpif {y2 < y1})
						(assign {x1} {xc})
						(assign {xc, x2} {x2, x1})
						(assign {y1} {xc})
						(assign {xc, y2} {y2, y1})
						(assign {-1} {xc})
					(else)
						(assign {1} {xc})
					(endif)
					(breakif {y2 <= this->canvas_cy})
					(breakif {y1 >= this->canvas_cy1})
					(assign {(x2 - x1) // (y2 - y1)} {iter_edge2->edge_dda})
					(vpif {y1 < this->canvas_cy})
						(assign {(this->canvas_cy - y1) * iter_edge2->edge_dda + x1} {x1})
						(assign {this->canvas_cy} {y1})
					(endif)
					(assign {x1} {iter_edge2->edge_x})
					(assign {y1} {iter_edge2->edge_ys})
					(assign {y2} {iter_edge2->edge_ye})
					(assign {xc} {iter_edge2->edge_w})
					(vpif {y1 < ys})
						(assign {y1} {ys})
					(endif)
					(vpif {y2 > ye})
						(assign {y2} {ye})
					(endif)
					(assign {iter_edge2 + edge_size} {iter_edge2})
				(endif)
				(assign {iter_begin_polygon[0] + x} {x1})
				(assign {(iter_begin_polygon[long_size] + y) >>> fp_shift} {y1})
				(assign {iter_begin_polygon + long_size * 2} {iter_begin_polygon})
			(loop-until {iter_begin_polygon == iter_end_polygon})
			(assign {(iter_edge2 - iter_edge1) >> 3} {length})
		(endif)
		(assign {iter_begin_polygons + ptr_size} {iter_begin_polygons})
	(loop-end)
	(call 'array 'set_length {this->canvas_edges, length})

	(exit 'canvas 'set_edges {this, xs, ys, xe, ye})
	(pop-scope)
	(return)

(vp-label 'mask_to_alpha)
	(apply vp-byte (map (lambda (m)
		(div (mul 0xff (apply add (map (lambda (s)
			(bit-and 1 (bit-shr m s))) (const '(range 0 8))))) 8)) (const '(range 0 256))))

(def-func-end)

(def-method 'canvas 'fpoly)
	;inputs
	;r0 = canvas object (ptr)
	;r1 = x (16.16)
	;r2 = y (16.16)
	;r3 = winding mode (0/1)
	;r4 = vector of points objects (ptr)
	;outputs
	;r0 = canvas object (ptr)
	;trashes
	;all but r0

	(ptr 'this)
	(union
		'(ptr 'polygons)
		'(pint 'sorted_list)
		'(pint 'tracker_node 'tracker_last 'tracker_list))
	(int 'ys 'ye 'xs 'xe 'x 'y)
	(uint 'mode)

	(push-scope)
	(entry 'canvas 'fpoly {this, x, y, mode, polygons})

	;fill edges, find min and max xy, clip edges not visible or redundant
	(call 'canvas 'set_edges {this, polygons, x, y} {_, xs, ys, xe, ye})

	;clip check
	(vpif {xs < this->canvas_cx1 && xe > this->canvas_cx && ys < this->canvas_cy1 && ye > this->canvas_cy})
		;setup active edge list and edge starts
		(assign {0} {tracker_list})
		(vpifnot {this->canvas_edges_start})
			(call 'sys_mem 'calloc {this->canvas_height * 8 * ptr_size} {this->canvas_edges_start, _})
		(endif)

		;edge pointers into edge starts
		(call 'array 'get_iters {this->canvas_edges} {_, tracker_node, tracker_last})
		(vp-def (edges_start edge_node edge_last edge_tmp edge_list_head))
		(assign {this->canvas_edges_start, tracker_node, tracker_last}
			(list edges_start edge_node edge_last))
		(loop-start)
			(vp-cpy-ir-i edge_node edge_ys edge_list_head)
			(vp-mul-cr ptr_size edge_list_head)
			(vp-add-rr edges_start edge_list_head)
			(ln-add-fnode edge_list_head 0 edge_node edge_tmp)
			(vp-add-cr edge_size edge_node)
		(loop-until `(,edge_node == ,edge_last))

		(loop-while {ys < ye})
			(breakif {ys >= this->canvas_cy1})

			;include new edges that begin on this scan line
			(vp-def (tracker_list_head starts_node starts_last starts_new starts_tmp ys y))
			(assign {&(this->canvas_edges_start)[ys * ptr_size], &tracker_list, ys}
				(list starts_node tracker_list_head ys))
			(loop-start)
				(ln-next-fnode starts_node starts_last)
				(vp-cpy-ir-i starts_node edge_ys y)
				(continueif `(,y != ,ys))
				(vp-cpy-rr starts_node starts_new)
				(ln-remove-fnode starts_node starts_last)
				(ln-add-fnode tracker_list_head 0 starts_new starts_tmp)
			(loop-end)

			;sort active edges on x
			(assign {0} {sorted_list})
			(vp-def (sorted_list_head tracker_node tracker_last tracker_new sorted_node sorted_last x1 x2))
			(assign {&sorted_list, &tracker_list} (list sorted_list_head tracker_node))
			(loop-start)
				(ln-next-fnode tracker_node tracker_last)
				(vp-cpy-rr tracker_node tracker_new)
				(ln-remove-fnode tracker_node tracker_last)
				(vp-cpy-ir-i tracker_new edge_x x1)
				(loop-flist sorted_list_head 0 sorted_node sorted_last)
					(vp-cpy-ir-i sorted_node edge_x x2)
				(loop-until `(,x1 <= ,x2))
				(ln-add-fnode sorted_last 0 tracker_new tracker_last)
			(loop-end)
			(assign {sorted_list} {tracker_list})

			;draw spans for mode
			(vp-def (this x1 y x2 w v tracker_node) (method-input 'canvas 'span))
			(assign {mode, this, &tracker_list} (list v this tracker_node))
			(vpif `(,v != 0))
				;odd even
				(loop-start)
					(ln-next-fnode tracker_node tracker_node)
					(assign {ys} (list y))
					(vp-cpy-ir-i tracker_node edge_x x1)
					(vp-cpy-ir tracker_node ln_fnode_next tracker_node)
					(vp-cpy-ir-i tracker_node edge_x x2)
					(vp-asr-cr fp_shift x1)
					(vp-asr-cr fp_shift x2)
					(assign (list tracker_node) {tracker_node})
					(call 'canvas 'span (list this x1 y x2) (list this))
					(assign {tracker_node} (list tracker_node))
				(loop-end)
			(else)
				;non zero
				(loop-start)
					(ln-next-fnode tracker_node tracker_node)
					(assign {ys} (list y))
					(vp-cpy-ir-i tracker_node edge_x x1)
					(vp-cpy-ir-i tracker_node edge_w w)
					(loop-start)
						(vp-cpy-ir tracker_node ln_fnode_next tracker_node)
						(vp-cpy-ir-i tracker_node edge_w v)
						(vp-cpy-ir-i tracker_node edge_x x2)
						(vp-add-rr v w)
					(loop-until `(,w == 0))
					(vp-asr-cr fp_shift x1)
					(vp-asr-cr fp_shift x2)
					(assign (list tracker_node) {tracker_node})
					(call 'canvas 'span (list this x1 y x2) (list this))
					(assign {tracker_node} (list tracker_node))
				(loop-end)
			(endif)

			;step the edges and remove any dead ones
			(assign {ys + 1} {ys})
			(vp-def (tracker_node tracker_last ys x dda))
			(assign {&tracker_list, ys} (list tracker_node ys))
			(loop-start)
			(vp-label 'start)
				(ln-next-fnode tracker_node tracker_last)
				(vp-cpy-ir-i tracker_node edge_ye x)
				(vpif `(,x != ,ys))
					(vp-cpy-ir-i tracker_node edge_x x)
					(vp-cpy-ir-i tracker_node edge_dda dda)
					(vp-add-rr dda x)
					(vp-cpy-ri-i x tracker_node edge_x)
					(goto 'start)
				(endif)
				(ln-remove-fnode tracker_node tracker_last)
			(loop-end)
		(loop-end)
	(endif)

	(exit 'canvas 'fpoly {this})
	(pop-scope)
	(return)

(def-func-end)
