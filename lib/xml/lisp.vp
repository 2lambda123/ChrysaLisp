(include "sys/func.inc")
(include "class/sym/class.inc")
(include "sys/str/class.inc")
(include "class/sstream/class.inc")
(include "class/list/class.inc")
(include "class/lisp/class.inc")
(include "lib/consts/chars.inc")

(def-func 'lib/xml/parse)
	;inputs
	;r0 = lisp object (ptr)
	;r1 = args list object (ptr)
	;outputs
	;r0 = lisp object (ptr)
	;r1 = return value object (ptr)
	;trashes
	;r1-r14

	(def-vars
		(int c)
		(ptr state)
		(offset res_start)
		(ptr states tokens ;must be first 2 resources !
			sym_text sym_open sym_close sym_assign sym_string sym_symbol
			not_symbol_chars open_chars close_chars sstoken)
		(offset res_end)
		(ptr stream resources this args))

	(defq find_in (method-input 'str :find)
		find_out (method-output 'str :find)
		push_back_in (method-input 'list :push_back))

	(defun write-token ()
		(call 'sstream :write_char {sstoken, c}))

	(defun output-c ()
		(call 'str :create_from_buffer {&c, 1} `(,(second push_back_in)))
		(assign {tokens} `(,(first push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-token ()
		(call 'sstream :claim_string {sstoken} `(_ ,(second push_back_in)))
		(assign {tokens} `(,(first push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-state (&optional s)
		(if s
			(assign (cat {states,} s) push_back_in)
			(assign {states, state} push_back_in))
		(class/obj/ref (second push_back_in) r14)
		(call 'list :push_back push_back_in))

	(defun find_char_in (s)
		(assign (cat s {,c}) find_in)
		(d-call 'str :find find_in find_out))

	(entry '(r0 r1))

(errorcases
	(call 'lisp :env_args_sig '(r1 ($ sig) 1) '(r2))
	(gotoif '(r2 = 0) 'error))

	(push-scope)
	(assign '(r0 r1) {this, args})

	(list-bind-args r1 '(r0) '(:stream))
	(assign '(r0) {stream})

	(call 'list :create nil {resources})
	(call 'str :create_from_buffer {0, str_gap} '(r0))
	(call 'sstream :create '(r0) {sstoken})
	(call 'list :create nil {states})
	(call 'list :create nil {tokens})
	(call 'sym :intern_cstr {":text"} {sym_text})
	(call 'sym :intern_cstr {":open"} {sym_open})
	(call 'sym :intern_cstr {":close"} {sym_close})
	(call 'sym :intern_cstr {":assign"} {sym_assign})
	(call 'sym :intern_cstr {":string"} {sym_string})
	(call 'sym :intern_cstr {":symbol"} {sym_symbol})
	(call 'str :create_from_buffer (list (cat (char +char_double_quote) {=<>}) 4) {not_symbol_chars})
	(call 'str :create_from_buffer {"</!-?", 5} {open_chars})
	(call 'str :create_from_buffer {">/-?", 4} {close_chars})

	(assign {resources, &res_start, &res_end} '(r0 r13 r14))
	(loop-start)
		(assign '(r0 (r13 0)) push_back_in)
		(vp-add-cr +ptr_size r13)
		(call 'list :push_back push_back_in)
	(loop-until '(r13 = r14))

	(assign {sym_text} {state})
	(loop-start 'next_char)
		(call 'stream :read_char {stream} {_, c})
		(breakif {c = -1})
	(vp-label 'proc_char)
		(switch)
		(vpcase {state = sym_text})
			(switch)
			(continueif {c <= +char_space} 'next_char)
			(vpcase {c = +char_lt})
				(assign {sym_open} {state})
				(goto 'write_token_then_next)
			(default)
				(find_char_in {close_chars})
				(nextcaseif `(,(third find_out) = -1))
				(assign {sym_close} {state})
				(goto 'write_token_then_next)
			(vpcase {c = +char_equal})
				(output-c)
				(output-state {sym_assign})
				(continue 'next_char)
			(vpcase {c = +char_double_quote})
				(assign {sym_string} {state})
				(continue 'next_char)
			(default)
				(assign {sym_symbol} {state})
				(goto 'write_token_then_next)
			(endswitch)
		(vpcase {state = sym_open})
			(find_char_in {open_chars})
			(gotoif `(,(third find_out) /= -1) 'write_token_then_next)
			(goto 'output_then_proc)
		(vpcase {state = sym_close})
			(find_char_in {close_chars})
			(gotoif `(,(third find_out) /= -1) 'write_token_then_next)
			(goto 'output_then_proc)
		(vpcase {state = sym_symbol})
			(gotoif {c <= +char_space} 'output_then_proc)
			(find_char_in {not_symbol_chars})
			(gotoif `(,(third find_out) = -1) 'write_token_then_next)
		(vp-label 'output_then_proc)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(goto 'proc_char)
		(default)
			(gotoif {c /= +char_double_quote} 'write_token_then_next)
		(vp-label 'output_then_next)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(continue 'next_char)
		(vp-label 'write_token_then_next)
			(write-token)
		(endswitch)
	(loop-end)

	(d-call 'list :slice {resources, 0, 2} {_, args})
	(call 'list :deref {resources})
	(exit {this, args})
	(pop-scope)
	(return)

(errorcases
(vp-label 'error)
	(jump 'lisp :repl_error '(r0 "(xml-parse stream)" error_msg_wrong_types r1))
	(signature '(stream)))

(def-func-end)
