(include "sys/func.inc")
(include "class/sym/class.inc")
(include "sys/str/class.inc")
(include "class/sstream/class.inc")
(include "class/list/class.inc")
(include "class/lisp/class.inc")
(include "lib/consts/chars.inc")

(def-func 'lib/xml/parse)
	;inputs
	;:r0 = lisp object (ptr)
	;:r1 = args list object (ptr)
	;outputs
	;:r0 = lisp object (ptr)
	;:r1 = return value object (ptr)
	;trashes
	;:r1-:r14

	(def-vars
		(int c)
		(ptr state)
	(offset res_start)
		(ptr states tokens) ;must be first 2 resources !
	(offset syms_start)
		(ptr sym_text sym_open sym_close sym_assign sym_string sym_symbol)
	(offset syms_end)
		(ptr not_symbol_chars open_chars close_chars sstoken)
	(offset res_end)
		(ptr stream resources this args))

	(defun write-token ()
		(call 'sstream :write_char {sstoken, c}))

	(defun output-c ()
		(call 'str :create_from_buffer {&c, 1} '(:token))
		(call 'list :push_back {tokens, :token}))

	(defun output-token ()
		(call 'sstream :claim_string {sstoken} '(_ :token))
		(call 'list :push_back {tokens, :token}))

	(defun output-state (&optional s)
		(if s
			(call 'list :push_back (cat {states,} s) '(_ :state :tmp _))
			(call 'list :push_back {states, state} '(_ :state :tmp _)))
		(class/obj/ref (get :state) (get :tmp)))

	(defun find_char_in (s)
		(d-call 'str :find (cat s {,c}) '(_ _ :idx)))

	(entry '(:r0 :r1))

(errorcases
	(call 'lisp :env_args_sig '(:r1 ($ sig) 1) '(:r2))
	(gotoif '(:r2 = 0) 'error))

	(push-scope)
	(assign '(:r0 :r1) {this, args})

	(list-bind-args :r1 '(:r0) '(:stream))
	(assign '(:r0) {stream})

	(call 'list :create nil {resources})
	(call 'str :create_from_buffer {0, str_gap} '(:r0))
	(call 'sstream :create '(:r0) {sstoken})
	(call 'list :create nil {states})
	(call 'list :create nil {tokens})
	(call 'str :create_from_buffer (list (cat (char +char_double_quote) {=<>}) 4) {not_symbol_chars})
	(call 'str :create_from_buffer {"</!-?", 5} {open_chars})
	(call 'str :create_from_buffer {">/-?", 4} {close_chars})

	;create state symbols
	(vp-def (:table :iter_begin :iter_end) '(:r11 :r12 :r13))
	(assign {$states, &syms_start, &syms_end} '(:table :iter_begin :iter_end))
	(loop-start)
		(call 'sym :intern_cstr '(:table) `((,(get :iter_begin) 0)))
		(call 'sys_str :length '(:table) '(_ :len))
		(vp-add-cr +ptr_size :iter_begin)
		(vp-add-rr :len :table)
		(vp-add-cr 1 :table)
	(loop-until '(:iter_begin = :iter_end))

	;create resource tracker list
	(vp-def (:res :iter_begin :iter_end) '(:r0 :r12 :r13))
	(assign {resources, &res_start, &res_end} '(:res :iter_begin :iter_end))
	(loop-start)
		(call 'list :push_back '(:res (:iter_begin 0)) '(:res _ _ _))
		(vp-add-cr +ptr_size :iter_begin)
	(loop-until '(:iter_begin = :iter_end))

	(assign {sym_text} {state})
	(loop-start 'next_char)
		(call 'stream :read_char {stream} {_, c})
		(breakif {c = -1})
	(vp-label 'proc_char)
		(switch)
		(vpcase {state = sym_text})
			(switch)
			(continueif {c <= +char_space} 'next_char)
			(vpcase {c = +char_lt})
				(assign {sym_open} {state})
				(goto 'write_token_then_next)
			(default)
				(find_char_in {close_chars})
				(nextcaseif '(:idx = -1))
				(assign {sym_close} {state})
				(goto 'write_token_then_next)
			(vpcase {c = +char_equal})
				(output-c)
				(output-state {sym_assign})
				(continue 'next_char)
			(vpcase {c = +char_double_quote})
				(assign {sym_string} {state})
				(continue 'next_char)
			(default)
				(assign {sym_symbol} {state})
				(goto 'write_token_then_next)
			(endswitch)
		(vpcase {state = sym_open})
			(find_char_in {open_chars})
			(gotoif '(:idx /= -1) 'write_token_then_next)
			(goto 'output_then_proc)
		(vpcase {state = sym_close})
			(find_char_in {close_chars})
			(gotoif '(:idx /= -1) 'write_token_then_next)
			(goto 'output_then_proc)
		(vpcase {state = sym_symbol})
			(gotoif {c <= +char_space} 'output_then_proc)
			(find_char_in {not_symbol_chars})
			(gotoif '(:idx = -1) 'write_token_then_next)
		(vp-label 'output_then_proc)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(goto 'proc_char)
		(default)
			(gotoif {c /= +char_double_quote} 'write_token_then_next)
		(vp-label 'output_then_next)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(continue 'next_char)
		(vp-label 'write_token_then_next)
			(write-token)
		(endswitch)
	(loop-end)

	(d-call 'list :slice {resources, 0, 2} {_, args})
	(call 'list :deref {resources})
	(exit {this, args})
	(pop-scope)
	(return)

(vp-label 'states)
	(vp-cstr ":text")
	(vp-cstr ":open")
	(vp-cstr ":close")
	(vp-cstr ":assign")
	(vp-cstr ":string")
	(vp-cstr ":symbol")

(errorcases
(vp-label 'error)
	(jump 'lisp :repl_error '(:r0 "(xml-parse stream)" +error_msg_wrong_types :r1))
	(signature '(stream)))

(def-func-end)
