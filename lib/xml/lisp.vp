(include "sys/func.inc")
(include "class/sym/class.inc")
(include "sys/str/class.inc")
(include "class/stream/class.inc")
(include "class/list/class.inc")
(include "class/lisp/class.inc")
(include "lib/consts/chars.inc")

(def-func 'lib/xml/parse)
	;inputs
	;r0 = lisp object (ptr)
	;r1 = args list object (ptr)
	;outputs
	;r0 = lisp object (ptr)
	;r1 = return value object (ptr)
	;trashes
	;r1-r14

	(def-vars
		(ptr this args stream state token states tokens resources
			not_symbol_chars open_chars close_chars)
		(ptr sym_text sym_open sym_close sym_assign sym_string sym_symbol)
		(int c))

	(defq find_in (method-input 'str :find)
		find_out (method-output 'str :find)
		str_cat_in (method-input 'str :cat)
		push_back_in (method-input 'list :push_back)
		push_back2_in (method-input 'list :push_back2))

	(defun push-token-c ()
		(call 'str :create_from_buffer {&c, 1} (list (elem 1 push_back_in)))
		(assign {token} (list (elem 0 push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-c ()
		(call 'str :create_from_buffer {&c, 1} (list (elem 1 push_back_in)))
		(assign {tokens} (list (elem 0 push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-token ()
		(assign {token} (list (elem 1 str_cat_in)))
		(d-call 'str :cat str_cat_in (list (elem 1 push_back_in)))
		(assign {tokens} (list (elem 0 push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-state (&optional s)
		(assign {states} (list (elem 0 push_back_in)))
		(if s
			(assign s (list (elem 1 push_back_in)))
			(assign {state} (list (elem 1 push_back_in))))
		(class/obj/ref (elem 1 push_back_in) r14)
		(call 'list :push_back push_back_in))

	(entry '(r0 r1))

(errorcases
	(call 'lisp :env_args_sig '(r1 ($ sig) 1) '(r2))
	(gotoif '(r2 = 0) 'error))

	(push-scope)
	(assign '(r0 r1) {this, args})

	(list-bind-args r1 '(r0) '(:stream))
	(assign '(r0) {stream})

	(call 'list :create nil {resources})
	(call 'list :create nil {token})
	(call 'list :create nil {states})
	(call 'list :create nil {tokens})
	(call 'sym :intern_cstr {":text"} {sym_text})
	(call 'sym :intern_cstr {":open"} {sym_open})
	(call 'sym :intern_cstr {":close"} {sym_close})
	(call 'sym :intern_cstr {":assign"} {sym_assign})
	(call 'sym :intern_cstr {":string"} {sym_string})
	(call 'sym :intern_cstr {":symbol"} {sym_symbol})
	(call 'str :create_from_buffer (list {""=<>} 5) {not_symbol_chars})
	(call 'str :create_from_buffer {"</?!-", 5} {open_chars})
	(call 'str :create_from_buffer {"-?/>", 4} {close_chars})

	(assign {resources, states, tokens} push_back2_in)
	(call 'list :push_back2 push_back2_in)
	(assign {sym_text, sym_open} (slice 1 -1 push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {sym_close, sym_assign} (slice 1 -1 push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {sym_string, sym_symbol} (slice 1 -1 push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {not_symbol_chars, open_chars} (slice 1 -1 push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {close_chars, token} (slice 1 -1 push_back2_in))
	(call 'list :push_back2 push_back2_in)

	(assign {sym_text} {state})
	(loop-start 'next_char)
		(call 'stream :read_char {stream} {_, c})
		(breakif {c = -1})
	(vp-label 'proc_char)
		(switch)
		(vpcase {state = sym_text})
			(switch)
			(continueif {c <= +char_space} 'next_char)
			(call 'list :clear {token})
			(vpcase {c = +char_lt})
				(push-token-c)
				(assign {sym_open} {state})
				(continue 'next_char)
			(default)
				(assign {close_chars, c} find_in)
				(d-call 'str :find find_in find_out)
				(nextcaseif (list (elem 2 find_out) '= -1))
				(push-token-c)
				(assign {sym_close} {state})
				(continue 'next_char)
			(vpcase {c = +char_equal})
				(output-c)
				(output-state "sym_assign")
				(assign {sym_text} {state})
				(continue 'next_char)
			(vpcase {c = +char_double_quote})
				(assign {sym_string} {state})
				(continue 'next_char)
			(default)
				(push-token-c)
				(assign {sym_symbol} {state})
				(continue 'next_char)
			(endswitch)
		(vpcase {state = sym_open})
			(assign {open_chars, c} find_in)
			(d-call 'str :find find_in find_out)
			(vpif (list (elem 2 find_out) '/= -1))
				(push-token-c)
				(continue 'next_char)
			(endif)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(goto 'proc_char)
		(vpcase {state = sym_close})
			(assign {close_chars, c} find_in)
			(d-call 'str :find find_in find_out)
			(vpif (list (elem 2 find_out) '/= -1))
				(push-token-c)
				(continue 'next_char)
			(endif)
			(output-token)
			(output-state)
			(assign {sym_text} {state})
			(goto 'proc_char)
		(vpcase {state = sym_symbol})
			(gotoif {c <= +char_space} 'not_symbol)
			(assign {not_symbol_chars, c} find_in)
			(d-call 'str :find find_in find_out)
			(vpif (list (elem 2 find_out) '/= -1))
		(vp-label 'not_symbol)
				(output-token)
				(output-state)
				(assign {sym_text} {state})
				(goto 'proc_char)
			(endif)
			(push-token-c)
			(continue 'next_char)
		(default)
			(vpif {c = +char_double_quote})
				(output-token)
				(output-state)
				(assign {sym_text} {state})
				(continue 'next_char)
			(endif)
			(push-token-c)
		(endswitch)
	(loop-end)

	(d-call 'list :slice {resources, 0, 2} {_, args})
	(call 'list :deref {resources})
	(exit {this, args})
	(pop-scope)
	(return)

(errorcases
(vp-label 'error)
	(jump 'lisp :repl_error '(r0 "(xml-parse stream)" error_msg_wrong_types r1))
	(signature '(stream)))

(def-func-end)
