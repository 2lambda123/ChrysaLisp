(include "sys/func.inc")
(include "class/sym/class.inc")
(include "sys/str/class.inc")
(include "class/stream/class.inc")
(include "class/list/class.inc")
(include "class/lisp/class.inc")
(include "lib/consts/chars.inc")

(def-func 'lib/xml/parse)
	;inputs
	;r0 = lisp object (ptr)
	;r1 = args list object (ptr)
	;outputs
	;r0 = lisp object (ptr)
	;r1 = return value object (ptr)
	;trashes
	;r1-r14

	(def-vars
		(int c)
		(ptr state token states tokens
			sym_text sym_open sym_close sym_assign sym_string sym_symbol
			not_symbol_chars open_chars close_chars
			stream resources this args))

	(defq find_in (method-input 'str :find)
		find_out (method-output 'str :find)
		str_cat_in (method-input 'str :cat)
		push_back_in (method-input 'list :push_back)
		push_back2_in (method-input 'list :push_back2))

	(defun push-token-c ()
		(call 'str :create_from_buffer {&c, 1} `(,(second push_back_in)))
		(assign {token} `(,(first push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-c ()
		(call 'str :create_from_buffer {&c, 1} `(,(second push_back_in)))
		(assign {tokens} `(,(first push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-token ()
		(assign {token} `(,(second str_cat_in)))
		(d-call 'str :cat str_cat_in `(,(second push_back_in)))
		(assign {tokens} `(,(first push_back_in)))
		(call 'list :push_back push_back_in))

	(defun output-state (&optional s)
		(if s
			(assign (cat {states,} s) push_back_in)
			(assign {states, state} push_back_in))
		(class/obj/ref (second push_back_in) r14)
		(call 'list :push_back push_back_in))

	(defun find_char_in (s)
		(assign (cat s {,c}) find_in)
		(d-call 'str :find find_in find_out))

	(entry '(r0 r1))

(errorcases
	(call 'lisp :env_args_sig '(r1 ($ sig) 1) '(r2))
	(gotoif '(r2 = 0) 'error))

	(push-scope)
	(assign '(r0 r1) {this, args})

	(list-bind-args r1 '(r0) '(:stream))
	(assign '(r0) {stream})

	(call 'list :create nil {resources})
	(call 'list :create nil {token})
	(call 'list :create nil {states})
	(call 'list :create nil {tokens})
	(call 'sym :intern_cstr {":text"} {sym_text})
	(call 'sym :intern_cstr {":open"} {sym_open})
	(call 'sym :intern_cstr {":close"} {sym_close})
	(call 'sym :intern_cstr {":assign"} {sym_assign})
	(call 'sym :intern_cstr {":string"} {sym_string})
	(call 'sym :intern_cstr {":symbol"} {sym_symbol})
	(call 'str :create_from_buffer (list (cat (char +char_double_quote) {=<>}) 4) {not_symbol_chars})
	(call 'str :create_from_buffer {"</!-?", 5} {open_chars})
	(call 'str :create_from_buffer {">/-?", 4} {close_chars})

	(assign {resources, states, tokens} push_back2_in)
	(call 'list :push_back2 push_back2_in)
	(assign {sym_text, sym_open} (rest push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {sym_close, sym_assign} (rest push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {sym_string, sym_symbol} (rest push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {not_symbol_chars, open_chars} (rest push_back2_in))
	(call 'list :push_back2 push_back2_in)
	(assign {close_chars, token} (rest push_back2_in))
	(call 'list :push_back2 push_back2_in)

	(assign {sym_text} {state})
	(loop-start 'next_char)
		(call 'stream :read_char {stream} {_, c})
		(breakif {c = -1})
	(vp-label 'proc_char)
		(switch)
		(vpcase {state = sym_text})
			(switch)
			(continueif {c <= +char_space} 'next_char)
			(call 'list :clear {token})
			(vpcase {c = +char_lt})
				(assign {sym_open} {state})
				(goto 'push_token_then_next)
			(default)
				(find_char_in {close_chars})
				(nextcaseif `(,(third find_out) = -1))
				(assign {sym_close} {state})
				(goto 'push_token_then_next)
			(vpcase {c = +char_equal})
				(output-c)
				(output-state {sym_assign})
				(assign {sym_text} {state})
				(continue 'next_char)
			(vpcase {c = +char_double_quote})
				(assign {sym_string} {state})
				(continue 'next_char)
			(default)
				(assign {sym_symbol} {state})
				(goto 'push_token_then_next)
			(endswitch)
		(vpcase {state = sym_open})
			(find_char_in {open_chars})
			(gotoif `(,(third find_out) /= -1) 'push_token_then_next)
			(goto 'output_then_proc)
		(vpcase {state = sym_close})
			(find_char_in {close_chars})
			(gotoif `(,(third find_out) /= -1) 'push_token_then_next)
			(goto 'output_then_proc)
		(vpcase {state = sym_symbol})
			(gotoif {c <= +char_space} 'output_then_proc)
			(find_char_in {not_symbol_chars})
			(vpif `(,(third find_out) /= -1))
		(vp-label 'output_then_proc)
				(output-token)
				(output-state)
				(assign {sym_text} {state})
				(goto 'proc_char)
			(endif)
			(goto 'push_token_then_next)
		(default)
			(vpif {c = +char_double_quote})
		(vp-label 'output_then_next)
				(output-token)
				(output-state)
				(assign {sym_text} {state})
				(continue 'next_char)
			(endif)
		(vp-label 'push_token_then_next)
			(push-token-c)
		(endswitch)
	(loop-end)

	(d-call 'list :slice {resources, 0, 2} {_, args})
	(call 'list :deref {resources})
	(exit {this, args})
	(pop-scope)
	(return)

(errorcases
(vp-label 'error)
	(jump 'lisp :repl_error '(r0 "(xml-parse stream)" error_msg_wrong_types r1))
	(signature '(stream)))

(def-func-end)
