(include 'sys/func.inc)
(include 'sys/heap/class.inc)
(include 'sys/pii/class.inc)

(def-method 'sys_heap 'init)
	;inputs
	;r0 = heap (ptr)
	;r1 = cell size (bytes)
	;r2 = num cells (uint)
	;outputs
	;r0 = heap (ptr)
	;r1 = cell size (bytes)
	;trashes
	;r2

	(entry 'sys_heap 'init '(r0 r1 r2))

	;align cell to ptr_size
	(vp-add-cr (dec ptr_size) r1)
	(vp-and-cr (neg ptr_size) r1)
	(vp-cpy-ri-i r1 r0 hp_heap_cellsize)

	;at least 1 cell !
	(vp-mul-rr r1 r2)
	(vpif '(r1 > r2))
		(vp-cpy-rr r1 r2)
	(endif)

	;round up to next page size
	(vp-add-cr (add hp_block_size (dec ld_page_size)) r2)
	(vp-and-cr (neg ld_page_size) r2)
	(vp-cpy-ri-i r2 r0 hp_heap_blocksize)

	;init lists
	(vp-xor-rr r2 r2)
	(vp-cpy-ri r2 r0 hp_heap_free_flist)
	(vp-cpy-ri r2 r0 hp_heap_block_flist)

	(exit 'sys_heap 'init '(r0 r1))
	(vp-ret)

(def-func-end)

(def-method 'sys_heap 'deinit)
	;inputs
	;r0 = heap (ptr)
	;outputs
	;r0 = heap (ptr)
	;trashes
	;r1-r4

	(entry 'sys_heap 'deinit '(r4))

	(f-bind 'sys_mem 'statics r1)
	(vp-cpy-ir r1 0 r3)
	(loop-flist r4 hp_heap_block_flist r2 r1)
		(vp-cpy-rr r2 r0)
		(ln-remove-fnode r2 r1)
		(vp-cpy-ir-ui r0 hp_block_blocksize r1)
		(vp-sub-rr r1 r3)
		(call 'sys_pii 'munmap '(r0 r1 mmap_data))
	(loop-end)
	(f-bind 'sys_mem 'statics r1)
	(vp-cpy-ri r3 r1 0)

	(exit 'sys_heap 'deinit '(r4))
	(vp-ret)

(def-func-end)

(def-method 'sys_heap 'alloc)
	;inputs
	;r0 = heap (ptr)
	;outputs
	;r0 = heap (ptr)
	;r1 = cell (ptr)
	;trashes
	;r2

	(entry 'sys_heap 'alloc '(r0))

	(loop-start)
		(vp-cpy-ir r0 hp_heap_free_flist r1)
		(vpif '(r1 != 0))
			(vp-cpy-ir r1 ln_fnode_next r2)
			(vp-cpy-ri r2 r0 hp_heap_free_flist)

			(exit 'sys_heap 'alloc '(r0 r1))
			(vp-ret)
		(endif)
		(vp-push r3 r4 r5)
		(if (and debug_mode nil)	;t for guard page allocator
			(progn
				;guard page allocator
				(vp-cpy-ir-ui r0 hp_heap_cellsize r4)
				(vp-add-cr (add hp_block_size (dec ld_page_size)) r4)
				(vp-and-cr (neg ld_page_size) r4)
				(vp-add-cr ld_page_size r4)
				(vp-push r0)
				(call 'sys_pii 'mmap '(r4 -1 mmap_data) '(r3))
				(errorif '(r3 == 0) 'error)
				(f-bind 'sys_mem 'statics r2)
				(vp-cpy-ri-i r4 r3 hp_block_blocksize)
				(vp-cpy-ir r2 0 r0)
				(vp-add-rr r4 r0)
				(vp-cpy-ri r0 r2 0)
				(vp-cpy-cr ld_page_size r1)
				(vp-add-rr r3 r4)
				(vp-sub-rr r1 r4)
				(call 'sys_pii 'mprotect '(r4 r1 mprotect_none) '(r0))
				(errorif '(r0 != 0) 'error)
				(vp-pop r0)
				(ln-add-fnode r0 hp_heap_block_flist r3 r1)
				(vp-cpy-ir-ui r0 hp_heap_cellsize r1)
				(vp-xor-rr r2 r2)
				(vp-sub-rr r1 r4)
				(vp-cpy-ri r2 r4 ln_fnode_next))
			(progn
				;normal allocator
				(vp-cpy-ir-ui r0 hp_heap_cellsize r5)
				(vp-cpy-ir-ui r0 hp_heap_blocksize r3)
				(vp-push r0)
				(call 'sys_pii 'mmap '(r3 -1 mmap_data) '(r1))
				(errorif '(r1 == 0) 'error)
				(f-bind 'sys_mem 'statics r2)
				(vp-cpy-ri-i r3 r1 hp_block_blocksize)
				(vp-cpy-ir r2 0 r0)
				(vp-add-rr r3 r0)
				(vp-cpy-ri r0 r2 0)
				(vp-pop r0)
				(vp-add-rr r1 r3)
				(ln-add-fnode r0 hp_heap_block_flist r1 r2)
				(vp-add-cr hp_block_size r1)
				(vp-xor-rr r4 r4)
				(loop-start)
					(vp-lea-d r1 r5 r2)
					(breakif '(r2 > r3))
					(vp-cpy-ri r4 r1 ln_fnode_next)
					(vp-cpy-rr r1 r4)
					(vp-cpy-rr r2 r1)
				(loop-end)))
		(vp-cpy-ri r4 r0 hp_heap_free_flist)
		(vp-pop r3 r4 r5)
	(loop-end)

(errorcases
(vp-label 'error)
	(abort))

(def-func-end)

(def-method 'sys_heap 'collect)
	;inputs
	;r0 = heap (ptr)
	;outputs
	;r0 = heap (ptr)
	;trashes
	;r1-r11

	(vp-def (this blk blk_last blk_begin blk_end cel cel_last cel_size total)
		'(r3 r4 r5 r6 r7 r8 r9 r10 r11))

	(entry 'sys_heap 'collect `(,this))

	;current total
	(f-bind 'sys_mem 'statics r0)
	(vp-cpy-ir r0 0 total)

	;loop over all blocks
	(vp-cpy-ir-ui this hp_heap_cellsize cel_size)
	(loop-flist this hp_heap_block_flist blk blk_last 'block_loop)
		;clear list headers
		(vp-xor-rr r0 r0)
		(vp-cpy-ri r0 blk hp_block_free_flist)
		(vp-cpy-ri r0 blk hp_block_free_flist_tail)

		;range of this block
		(vp-cpy-ir-ui blk hp_block_blocksize blk_end)
		(vp-lea-i blk hp_block_size blk_begin)
		(vp-add-rr blk blk_end)

		;loop over free cells
		(vp-lea-i this hp_heap_free_flist cel)
		(loop-start)
			(vp-cpy-rr cel cel_last)
			(vp-cpy-ir cel ln_fnode_next cel)
			(continueif `(,cel == 0) 'block_loop)

			;is free cell within this block
			(continueif `(,cel < ,blk))
			(continueif `(,cel >= ,blk_end))

			;transfer to blocks free list
			(vp-cpy-rr cel r0)
			(ln-remove-fnode cel cel_last)
			(vp-cpy-ir blk hp_block_free_flist_tail r1)
			(ln-add-fnode blk hp_block_free_flist r0 r2)
			(vpif '(r1 == 0))
				(vp-cpy-ri r0 blk hp_block_free_flist_tail)
			(endif)

			;move on marker, does it show we have a free block
			(vp-add-rr cel_size blk_begin)
			(vp-cpy-rr blk_end r0)
			(vp-sub-rr blk_begin r0)
			(continueif `(r0 >= ,cel_size))

			;free the block
			(vp-cpy-rr blk r0)
			(vp-cpy-ir-ui blk hp_block_blocksize r1)
			(ln-remove-fnode blk blk_last)
			(vp-sub-rr r1 total)
			(call 'sys_pii 'munmap '(r0 r1 mmap_data))
			(continue 'block_loop)
		(endswitch)
	(endswitch)

	;loop over all blocks
	(loop-flist this hp_heap_block_flist blk blk)
		;splice any free cells onto free list
		(vp-cpy-ir blk hp_block_free_flist r0)
		(continueif '(r0 == 0))
		(vp-cpy-ir blk hp_block_free_flist_tail r1)
		(vp-cpy-ir this hp_heap_free_flist r2)
		(vp-cpy-ri r0 this hp_heap_free_flist)
		(vp-cpy-ri r2 r1 ln_fnode_next)
	(loop-end)

	;current total
	(f-bind 'sys_mem 'statics r0)
	(vp-cpy-ri total r0 0)

	(exit 'sys_heap 'collect `(,this))
	(vp-ret)

(def-func-end)
